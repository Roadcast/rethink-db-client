// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "Ql2.pb.h"

@implementation Ql2Root
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [Ql2Root class]) {
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    extensionRegistry = registry;
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
}
@end

@interface VersionDummy ()
@end

@implementation VersionDummy

- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static VersionDummy* defaultVersionDummyInstance = nil;
+ (void) initialize {
  if (self == [VersionDummy class]) {
    defaultVersionDummyInstance = [[VersionDummy alloc] init];
  }
}
+ (VersionDummy*) defaultInstance {
  return defaultVersionDummyInstance;
}
- (VersionDummy*) defaultInstance {
  return defaultVersionDummyInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (VersionDummy*) parseFromData:(NSData*) data {
  return (VersionDummy*)[[[VersionDummy builder] mergeFromData:data] build];
}
+ (VersionDummy*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (VersionDummy*)[[[VersionDummy builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (VersionDummy*) parseFromInputStream:(NSInputStream*) input {
  return (VersionDummy*)[[[VersionDummy builder] mergeFromInputStream:input] build];
}
+ (VersionDummy*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (VersionDummy*)[[[VersionDummy builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (VersionDummy*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (VersionDummy*)[[[VersionDummy builder] mergeFromCodedInputStream:input] build];
}
+ (VersionDummy*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (VersionDummy*)[[[VersionDummy builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (VersionDummy_Builder*) builder {
  return [[VersionDummy_Builder alloc] init];
}
+ (VersionDummy_Builder*) builderWithPrototype:(VersionDummy*) prototype {
  return [[VersionDummy builder] mergeFrom:prototype];
}
- (VersionDummy_Builder*) builder {
  return [VersionDummy builder];
}
- (VersionDummy_Builder*) toBuilder {
  return [VersionDummy builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[VersionDummy class]]) {
    return NO;
  }
  VersionDummy *otherMessage = other;
  return
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL VersionDummy_VersionIsValidValue(VersionDummy_Version value) {
  switch (value) {
    case VersionDummy_VersionV01:
    case VersionDummy_VersionV02:
      return YES;
    default:
      return NO;
  }
}
@interface VersionDummy_Builder()
@property (strong) VersionDummy* result;
@end

@implementation VersionDummy_Builder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[VersionDummy alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (VersionDummy_Builder*) clear {
  self.result = [[VersionDummy alloc] init];
  return self;
}
- (VersionDummy_Builder*) clone {
  return [VersionDummy builderWithPrototype:result];
}
- (VersionDummy*) defaultInstance {
  return [VersionDummy defaultInstance];
}
- (VersionDummy*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (VersionDummy*) buildPartial {
  VersionDummy* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (VersionDummy_Builder*) mergeFrom:(VersionDummy*) other {
  if (other == [VersionDummy defaultInstance]) {
    return self;
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (VersionDummy_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (VersionDummy_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
    }
  }
}
@end

@interface Query ()
@property Query_QueryType type;
@property (strong) Term* query;
@property int64_t token;
@property BOOL obsoleteNoreply;
@property BOOL acceptsRJson;
@property (strong) NSMutableArray * globalOptargsArray;
@end

@implementation Query

- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasQuery {
  return !!hasQuery_;
}
- (void) setHasQuery:(BOOL) value_ {
  hasQuery_ = !!value_;
}
@synthesize query;
- (BOOL) hasToken {
  return !!hasToken_;
}
- (void) setHasToken:(BOOL) value_ {
  hasToken_ = !!value_;
}
@synthesize token;
- (BOOL) hasObsoleteNoreply {
  return !!hasObsoleteNoreply_;
}
- (void) setHasObsoleteNoreply:(BOOL) value_ {
  hasObsoleteNoreply_ = !!value_;
}
- (BOOL) obsoleteNoreply {
  return !!obsoleteNoreply_;
}
- (void) setObsoleteNoreply:(BOOL) value {
  obsoleteNoreply_ = !!value;
}
- (BOOL) hasAcceptsRJson {
  return !!hasAcceptsRJson_;
}
- (void) setHasAcceptsRJson:(BOOL) value_ {
  hasAcceptsRJson_ = !!value_;
}
- (BOOL) acceptsRJson {
  return !!acceptsRJson_;
}
- (void) setAcceptsRJson:(BOOL) value {
  acceptsRJson_ = !!value;
}
@synthesize globalOptargsArray;
@dynamic globalOptargs;
- (id) init {
  if ((self = [super init])) {
    self.type = Query_QueryTypeStart;
    self.query = [Term defaultInstance];
    self.token = 0L;
    self.obsoleteNoreply = NO;
    self.acceptsRJson = NO;
  }
  return self;
}
static Query* defaultQueryInstance = nil;
+ (void) initialize {
  if (self == [Query class]) {
    defaultQueryInstance = [[Query alloc] init];
  }
}
+ (Query*) defaultInstance {
  return defaultQueryInstance;
}
- (Query*) defaultInstance {
  return defaultQueryInstance;
}
- (NSArray *)globalOptargs {
  return globalOptargsArray;
}
- (Query_AssocPair*)globalOptargsAtIndex:(NSUInteger)index {
  return [globalOptargsArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  if (self.hasQuery) {
    if (!self.query.isInitialized) {
      return NO;
    }
  }
  for (Query_AssocPair* element in self.globalOptargs) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasType) {
    [output writeEnum:1 value:self.type];
  }
  if (self.hasQuery) {
    [output writeMessage:2 value:self.query];
  }
  if (self.hasToken) {
    [output writeInt64:3 value:self.token];
  }
  if (self.hasObsoleteNoreply) {
    [output writeBool:4 value:self.obsoleteNoreply];
  }
  if (self.hasAcceptsRJson) {
    [output writeBool:5 value:self.acceptsRJson];
  }
  for (Query_AssocPair *element in self.globalOptargsArray) {
    [output writeMessage:6 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasType) {
    size_ += computeEnumSize(1, self.type);
  }
  if (self.hasQuery) {
    size_ += computeMessageSize(2, self.query);
  }
  if (self.hasToken) {
    size_ += computeInt64Size(3, self.token);
  }
  if (self.hasObsoleteNoreply) {
    size_ += computeBoolSize(4, self.obsoleteNoreply);
  }
  if (self.hasAcceptsRJson) {
    size_ += computeBoolSize(5, self.acceptsRJson);
  }
  for (Query_AssocPair *element in self.globalOptargsArray) {
    size_ += computeMessageSize(6, element);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Query*) parseFromData:(NSData*) data {
  return (Query*)[[[Query builder] mergeFromData:data] build];
}
+ (Query*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Query*)[[[Query builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Query*) parseFromInputStream:(NSInputStream*) input {
  return (Query*)[[[Query builder] mergeFromInputStream:input] build];
}
+ (Query*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Query*)[[[Query builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Query*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Query*)[[[Query builder] mergeFromCodedInputStream:input] build];
}
+ (Query*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Query*)[[[Query builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Query_Builder*) builder {
  return [[Query_Builder alloc] init];
}
+ (Query_Builder*) builderWithPrototype:(Query*) prototype {
  return [[Query builder] mergeFrom:prototype];
}
- (Query_Builder*) builder {
  return [Query builder];
}
- (Query_Builder*) toBuilder {
  return [Query builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasType) {
    [output appendFormat:@"%@%@: %d\n", indent, @"type", self.type];
  }
  if (self.hasQuery) {
    [output appendFormat:@"%@%@ {\n", indent, @"query"];
    [self.query writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  if (self.hasToken) {
    [output appendFormat:@"%@%@: %@\n", indent, @"token", [NSNumber numberWithLongLong:self.token]];
  }
  if (self.hasObsoleteNoreply) {
    [output appendFormat:@"%@%@: %@\n", indent, @"obsoleteNoreply", [NSNumber numberWithBool:self.obsoleteNoreply]];
  }
  if (self.hasAcceptsRJson) {
    [output appendFormat:@"%@%@: %@\n", indent, @"acceptsRJson", [NSNumber numberWithBool:self.acceptsRJson]];
  }
  for (Query_AssocPair* element in self.globalOptargsArray) {
    [output appendFormat:@"%@%@ {\n", indent, @"globalOptargs"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Query class]]) {
    return NO;
  }
  Query *otherMessage = other;
  return
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasQuery == otherMessage.hasQuery &&
      (!self.hasQuery || [self.query isEqual:otherMessage.query]) &&
      self.hasToken == otherMessage.hasToken &&
      (!self.hasToken || self.token == otherMessage.token) &&
      self.hasObsoleteNoreply == otherMessage.hasObsoleteNoreply &&
      (!self.hasObsoleteNoreply || self.obsoleteNoreply == otherMessage.obsoleteNoreply) &&
      self.hasAcceptsRJson == otherMessage.hasAcceptsRJson &&
      (!self.hasAcceptsRJson || self.acceptsRJson == otherMessage.acceptsRJson) &&
      [self.globalOptargsArray isEqualToArray:otherMessage.globalOptargsArray] &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasQuery) {
    hashCode = hashCode * 31 + [self.query hash];
  }
  if (self.hasToken) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.token] hash];
  }
  if (self.hasObsoleteNoreply) {
    hashCode = hashCode * 31 + [[NSNumber numberWithBool:self.obsoleteNoreply] hash];
  }
  if (self.hasAcceptsRJson) {
    hashCode = hashCode * 31 + [[NSNumber numberWithBool:self.acceptsRJson] hash];
  }
  for (Query_AssocPair* element in self.globalOptargsArray) {
    hashCode = hashCode * 31 + [element hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL Query_QueryTypeIsValidValue(Query_QueryType value) {
  switch (value) {
    case Query_QueryTypeStart:
    case Query_QueryTypeContinue:
    case Query_QueryTypeStop:
    case Query_QueryTypeNoreplyWait:
      return YES;
    default:
      return NO;
  }
}
@interface Query_AssocPair ()
@property (strong) NSString* key;
@property (strong) Term* val;
@end

@implementation Query_AssocPair

- (BOOL) hasKey {
  return !!hasKey_;
}
- (void) setHasKey:(BOOL) value_ {
  hasKey_ = !!value_;
}
@synthesize key;
- (BOOL) hasVal {
  return !!hasVal_;
}
- (void) setHasVal:(BOOL) value_ {
  hasVal_ = !!value_;
}
@synthesize val;
- (id) init {
  if ((self = [super init])) {
    self.key = @"";
    self.val = [Term defaultInstance];
  }
  return self;
}
static Query_AssocPair* defaultQuery_AssocPairInstance = nil;
+ (void) initialize {
  if (self == [Query_AssocPair class]) {
    defaultQuery_AssocPairInstance = [[Query_AssocPair alloc] init];
  }
}
+ (Query_AssocPair*) defaultInstance {
  return defaultQuery_AssocPairInstance;
}
- (Query_AssocPair*) defaultInstance {
  return defaultQuery_AssocPairInstance;
}
- (BOOL) isInitialized {
  if (self.hasVal) {
    if (!self.val.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasKey) {
    [output writeString:1 value:self.key];
  }
  if (self.hasVal) {
    [output writeMessage:2 value:self.val];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasKey) {
    size_ += computeStringSize(1, self.key);
  }
  if (self.hasVal) {
    size_ += computeMessageSize(2, self.val);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Query_AssocPair*) parseFromData:(NSData*) data {
  return (Query_AssocPair*)[[[Query_AssocPair builder] mergeFromData:data] build];
}
+ (Query_AssocPair*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Query_AssocPair*)[[[Query_AssocPair builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Query_AssocPair*) parseFromInputStream:(NSInputStream*) input {
  return (Query_AssocPair*)[[[Query_AssocPair builder] mergeFromInputStream:input] build];
}
+ (Query_AssocPair*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Query_AssocPair*)[[[Query_AssocPair builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Query_AssocPair*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Query_AssocPair*)[[[Query_AssocPair builder] mergeFromCodedInputStream:input] build];
}
+ (Query_AssocPair*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Query_AssocPair*)[[[Query_AssocPair builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Query_AssocPair_Builder*) builder {
  return [[Query_AssocPair_Builder alloc] init];
}
+ (Query_AssocPair_Builder*) builderWithPrototype:(Query_AssocPair*) prototype {
  return [[Query_AssocPair builder] mergeFrom:prototype];
}
- (Query_AssocPair_Builder*) builder {
  return [Query_AssocPair builder];
}
- (Query_AssocPair_Builder*) toBuilder {
  return [Query_AssocPair builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasKey) {
    [output appendFormat:@"%@%@: %@\n", indent, @"key", self.key];
  }
  if (self.hasVal) {
    [output appendFormat:@"%@%@ {\n", indent, @"val"];
    [self.val writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Query_AssocPair class]]) {
    return NO;
  }
  Query_AssocPair *otherMessage = other;
  return
      self.hasKey == otherMessage.hasKey &&
      (!self.hasKey || [self.key isEqual:otherMessage.key]) &&
      self.hasVal == otherMessage.hasVal &&
      (!self.hasVal || [self.val isEqual:otherMessage.val]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  if (self.hasKey) {
    hashCode = hashCode * 31 + [self.key hash];
  }
  if (self.hasVal) {
    hashCode = hashCode * 31 + [self.val hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface Query_AssocPair_Builder()
@property (strong) Query_AssocPair* result;
@end

@implementation Query_AssocPair_Builder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[Query_AssocPair alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (Query_AssocPair_Builder*) clear {
  self.result = [[Query_AssocPair alloc] init];
  return self;
}
- (Query_AssocPair_Builder*) clone {
  return [Query_AssocPair builderWithPrototype:result];
}
- (Query_AssocPair*) defaultInstance {
  return [Query_AssocPair defaultInstance];
}
- (Query_AssocPair*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Query_AssocPair*) buildPartial {
  Query_AssocPair* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (Query_AssocPair_Builder*) mergeFrom:(Query_AssocPair*) other {
  if (other == [Query_AssocPair defaultInstance]) {
    return self;
  }
  if (other.hasKey) {
    [self setKey:other.key];
  }
  if (other.hasVal) {
    [self mergeVal:other.val];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (Query_AssocPair_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (Query_AssocPair_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setKey:[input readString]];
        break;
      }
      case 18: {
        Term_Builder* subBuilder = [Term builder];
        if (self.hasVal) {
          [subBuilder mergeFrom:self.val];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setVal:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasKey {
  return result.hasKey;
}
- (NSString*) key {
  return result.key;
}
- (Query_AssocPair_Builder*) setKey:(NSString*) value {
  result.hasKey = YES;
  result.key = value;
  return self;
}
- (Query_AssocPair_Builder*) clearKey {
  result.hasKey = NO;
  result.key = @"";
  return self;
}
- (BOOL) hasVal {
  return result.hasVal;
}
- (Term*) val {
  return result.val;
}
- (Query_AssocPair_Builder*) setVal:(Term*) value {
  result.hasVal = YES;
  result.val = value;
  return self;
}
- (Query_AssocPair_Builder*) setValBuilder:(Term_Builder*) builderForValue {
  return [self setVal:[builderForValue build]];
}
- (Query_AssocPair_Builder*) mergeVal:(Term*) value {
  if (result.hasVal &&
      result.val != [Term defaultInstance]) {
    result.val =
      [[[Term builderWithPrototype:result.val] mergeFrom:value] buildPartial];
  } else {
    result.val = value;
  }
  result.hasVal = YES;
  return self;
}
- (Query_AssocPair_Builder*) clearVal {
  result.hasVal = NO;
  result.val = [Term defaultInstance];
  return self;
}
@end

@interface Query_Builder()
@property (strong) Query* result;
@end

@implementation Query_Builder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[Query alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (Query_Builder*) clear {
  self.result = [[Query alloc] init];
  return self;
}
- (Query_Builder*) clone {
  return [Query builderWithPrototype:result];
}
- (Query*) defaultInstance {
  return [Query defaultInstance];
}
- (Query*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Query*) buildPartial {
  Query* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (Query_Builder*) mergeFrom:(Query*) other {
  if (other == [Query defaultInstance]) {
    return self;
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasQuery) {
    [self mergeQuery:other.query];
  }
  if (other.hasToken) {
    [self setToken:other.token];
  }
  if (other.hasObsoleteNoreply) {
    [self setObsoleteNoreply:other.obsoleteNoreply];
  }
  if (other.hasAcceptsRJson) {
    [self setAcceptsRJson:other.acceptsRJson];
  }
  if (other.globalOptargsArray.count > 0) {
    if (result.globalOptargsArray == nil) {
      result.globalOptargsArray = [[NSMutableArray alloc] initWithArray:other.globalOptargsArray];
    } else {
      [result.globalOptargsArray addObjectsFromArray:other.globalOptargsArray];
    }
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (Query_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (Query_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        int32_t value = [input readEnum];
        if (Query_QueryTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 18: {
        Term_Builder* subBuilder = [Term builder];
        if (self.hasQuery) {
          [subBuilder mergeFrom:self.query];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setQuery:[subBuilder buildPartial]];
        break;
      }
      case 24: {
        [self setToken:[input readInt64]];
        break;
      }
      case 32: {
        [self setObsoleteNoreply:[input readBool]];
        break;
      }
      case 40: {
        [self setAcceptsRJson:[input readBool]];
        break;
      }
      case 50: {
        Query_AssocPair_Builder* subBuilder = [Query_AssocPair builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addGlobalOptargs:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasType {
  return result.hasType;
}
- (Query_QueryType) type {
  return result.type;
}
- (Query_Builder*) setType:(Query_QueryType) value {
  result.hasType = YES;
  result.type = value;
  return self;
}
- (Query_Builder*) clearType {
  result.hasType = NO;
  result.type = Query_QueryTypeStart;
  return self;
}
- (BOOL) hasQuery {
  return result.hasQuery;
}
- (Term*) query {
  return result.query;
}
- (Query_Builder*) setQuery:(Term*) value {
  result.hasQuery = YES;
  result.query = value;
  return self;
}
- (Query_Builder*) setQueryBuilder:(Term_Builder*) builderForValue {
  return [self setQuery:[builderForValue build]];
}
- (Query_Builder*) mergeQuery:(Term*) value {
  if (result.hasQuery &&
      result.query != [Term defaultInstance]) {
    result.query =
      [[[Term builderWithPrototype:result.query] mergeFrom:value] buildPartial];
  } else {
    result.query = value;
  }
  result.hasQuery = YES;
  return self;
}
- (Query_Builder*) clearQuery {
  result.hasQuery = NO;
  result.query = [Term defaultInstance];
  return self;
}
- (BOOL) hasToken {
  return result.hasToken;
}
- (int64_t) token {
  return result.token;
}
- (Query_Builder*) setToken:(int64_t) value {
  result.hasToken = YES;
  result.token = value;
  return self;
}
- (Query_Builder*) clearToken {
  result.hasToken = NO;
  result.token = 0L;
  return self;
}
- (BOOL) hasObsoleteNoreply {
  return result.hasObsoleteNoreply;
}
- (BOOL) obsoleteNoreply {
  return result.obsoleteNoreply;
}
- (Query_Builder*) setObsoleteNoreply:(BOOL) value {
  result.hasObsoleteNoreply = YES;
  result.obsoleteNoreply = value;
  return self;
}
- (Query_Builder*) clearObsoleteNoreply {
  result.hasObsoleteNoreply = NO;
  result.obsoleteNoreply = NO;
  return self;
}
- (BOOL) hasAcceptsRJson {
  return result.hasAcceptsRJson;
}
- (BOOL) acceptsRJson {
  return result.acceptsRJson;
}
- (Query_Builder*) setAcceptsRJson:(BOOL) value {
  result.hasAcceptsRJson = YES;
  result.acceptsRJson = value;
  return self;
}
- (Query_Builder*) clearAcceptsRJson {
  result.hasAcceptsRJson = NO;
  result.acceptsRJson = NO;
  return self;
}
- (NSMutableArray *)globalOptargs {
  return result.globalOptargsArray;
}
- (Query_AssocPair*)globalOptargsAtIndex:(NSUInteger)index {
  return [result globalOptargsAtIndex:index];
}
- (Query_Builder *)addGlobalOptargs:(Query_AssocPair*)value {
  if (result.globalOptargsArray == nil) {
    result.globalOptargsArray = [[NSMutableArray alloc]init];
  }
  [result.globalOptargsArray addObject:value];
  return self;
}
- (Query_Builder *)setGlobalOptargsArray:(NSArray *)array {
  result.globalOptargsArray = [[NSMutableArray alloc]init];
  return self;
}
- (Query_Builder *)clearGlobalOptargs {
  result.globalOptargsArray = nil;
  return self;
}
@end

@interface Frame ()
@property Frame_FrameType type;
@property int64_t pos;
@property (strong) NSString* opt;
@end

@implementation Frame

- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasPos {
  return !!hasPos_;
}
- (void) setHasPos:(BOOL) value_ {
  hasPos_ = !!value_;
}
@synthesize pos;
- (BOOL) hasOpt {
  return !!hasOpt_;
}
- (void) setHasOpt:(BOOL) value_ {
  hasOpt_ = !!value_;
}
@synthesize opt;
- (id) init {
  if ((self = [super init])) {
    self.type = Frame_FrameTypePos;
    self.pos = 0L;
    self.opt = @"";
  }
  return self;
}
static Frame* defaultFrameInstance = nil;
+ (void) initialize {
  if (self == [Frame class]) {
    defaultFrameInstance = [[Frame alloc] init];
  }
}
+ (Frame*) defaultInstance {
  return defaultFrameInstance;
}
- (Frame*) defaultInstance {
  return defaultFrameInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasType) {
    [output writeEnum:1 value:self.type];
  }
  if (self.hasPos) {
    [output writeInt64:2 value:self.pos];
  }
  if (self.hasOpt) {
    [output writeString:3 value:self.opt];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasType) {
    size_ += computeEnumSize(1, self.type);
  }
  if (self.hasPos) {
    size_ += computeInt64Size(2, self.pos);
  }
  if (self.hasOpt) {
    size_ += computeStringSize(3, self.opt);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Frame*) parseFromData:(NSData*) data {
  return (Frame*)[[[Frame builder] mergeFromData:data] build];
}
+ (Frame*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Frame*)[[[Frame builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Frame*) parseFromInputStream:(NSInputStream*) input {
  return (Frame*)[[[Frame builder] mergeFromInputStream:input] build];
}
+ (Frame*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Frame*)[[[Frame builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Frame*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Frame*)[[[Frame builder] mergeFromCodedInputStream:input] build];
}
+ (Frame*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Frame*)[[[Frame builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Frame_Builder*) builder {
  return [[Frame_Builder alloc] init];
}
+ (Frame_Builder*) builderWithPrototype:(Frame*) prototype {
  return [[Frame builder] mergeFrom:prototype];
}
- (Frame_Builder*) builder {
  return [Frame builder];
}
- (Frame_Builder*) toBuilder {
  return [Frame builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasType) {
    [output appendFormat:@"%@%@: %d\n", indent, @"type", self.type];
  }
  if (self.hasPos) {
    [output appendFormat:@"%@%@: %@\n", indent, @"pos", [NSNumber numberWithLongLong:self.pos]];
  }
  if (self.hasOpt) {
    [output appendFormat:@"%@%@: %@\n", indent, @"opt", self.opt];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Frame class]]) {
    return NO;
  }
  Frame *otherMessage = other;
  return
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasPos == otherMessage.hasPos &&
      (!self.hasPos || self.pos == otherMessage.pos) &&
      self.hasOpt == otherMessage.hasOpt &&
      (!self.hasOpt || [self.opt isEqual:otherMessage.opt]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasPos) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.pos] hash];
  }
  if (self.hasOpt) {
    hashCode = hashCode * 31 + [self.opt hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL Frame_FrameTypeIsValidValue(Frame_FrameType value) {
  switch (value) {
    case Frame_FrameTypePos:
    case Frame_FrameTypeOpt:
      return YES;
    default:
      return NO;
  }
}
@interface Frame_Builder()
@property (strong) Frame* result;
@end

@implementation Frame_Builder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[Frame alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (Frame_Builder*) clear {
  self.result = [[Frame alloc] init];
  return self;
}
- (Frame_Builder*) clone {
  return [Frame builderWithPrototype:result];
}
- (Frame*) defaultInstance {
  return [Frame defaultInstance];
}
- (Frame*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Frame*) buildPartial {
  Frame* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (Frame_Builder*) mergeFrom:(Frame*) other {
  if (other == [Frame defaultInstance]) {
    return self;
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasPos) {
    [self setPos:other.pos];
  }
  if (other.hasOpt) {
    [self setOpt:other.opt];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (Frame_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (Frame_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        int32_t value = [input readEnum];
        if (Frame_FrameTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 16: {
        [self setPos:[input readInt64]];
        break;
      }
      case 26: {
        [self setOpt:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasType {
  return result.hasType;
}
- (Frame_FrameType) type {
  return result.type;
}
- (Frame_Builder*) setType:(Frame_FrameType) value {
  result.hasType = YES;
  result.type = value;
  return self;
}
- (Frame_Builder*) clearType {
  result.hasType = NO;
  result.type = Frame_FrameTypePos;
  return self;
}
- (BOOL) hasPos {
  return result.hasPos;
}
- (int64_t) pos {
  return result.pos;
}
- (Frame_Builder*) setPos:(int64_t) value {
  result.hasPos = YES;
  result.pos = value;
  return self;
}
- (Frame_Builder*) clearPos {
  result.hasPos = NO;
  result.pos = 0L;
  return self;
}
- (BOOL) hasOpt {
  return result.hasOpt;
}
- (NSString*) opt {
  return result.opt;
}
- (Frame_Builder*) setOpt:(NSString*) value {
  result.hasOpt = YES;
  result.opt = value;
  return self;
}
- (Frame_Builder*) clearOpt {
  result.hasOpt = NO;
  result.opt = @"";
  return self;
}
@end

@interface Backtrace ()
@property (strong) NSMutableArray * framesArray;
@end

@implementation Backtrace

@synthesize framesArray;
@dynamic frames;
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static Backtrace* defaultBacktraceInstance = nil;
+ (void) initialize {
  if (self == [Backtrace class]) {
    defaultBacktraceInstance = [[Backtrace alloc] init];
  }
}
+ (Backtrace*) defaultInstance {
  return defaultBacktraceInstance;
}
- (Backtrace*) defaultInstance {
  return defaultBacktraceInstance;
}
- (NSArray *)frames {
  return framesArray;
}
- (Frame*)framesAtIndex:(NSUInteger)index {
  return [framesArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (Frame *element in self.framesArray) {
    [output writeMessage:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  for (Frame *element in self.framesArray) {
    size_ += computeMessageSize(1, element);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Backtrace*) parseFromData:(NSData*) data {
  return (Backtrace*)[[[Backtrace builder] mergeFromData:data] build];
}
+ (Backtrace*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Backtrace*)[[[Backtrace builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Backtrace*) parseFromInputStream:(NSInputStream*) input {
  return (Backtrace*)[[[Backtrace builder] mergeFromInputStream:input] build];
}
+ (Backtrace*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Backtrace*)[[[Backtrace builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Backtrace*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Backtrace*)[[[Backtrace builder] mergeFromCodedInputStream:input] build];
}
+ (Backtrace*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Backtrace*)[[[Backtrace builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Backtrace_Builder*) builder {
  return [[Backtrace_Builder alloc] init];
}
+ (Backtrace_Builder*) builderWithPrototype:(Backtrace*) prototype {
  return [[Backtrace builder] mergeFrom:prototype];
}
- (Backtrace_Builder*) builder {
  return [Backtrace builder];
}
- (Backtrace_Builder*) toBuilder {
  return [Backtrace builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  for (Frame* element in self.framesArray) {
    [output appendFormat:@"%@%@ {\n", indent, @"frames"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Backtrace class]]) {
    return NO;
  }
  Backtrace *otherMessage = other;
  return
      [self.framesArray isEqualToArray:otherMessage.framesArray] &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  for (Frame* element in self.framesArray) {
    hashCode = hashCode * 31 + [element hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface Backtrace_Builder()
@property (strong) Backtrace* result;
@end

@implementation Backtrace_Builder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[Backtrace alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (Backtrace_Builder*) clear {
  self.result = [[Backtrace alloc] init];
  return self;
}
- (Backtrace_Builder*) clone {
  return [Backtrace builderWithPrototype:result];
}
- (Backtrace*) defaultInstance {
  return [Backtrace defaultInstance];
}
- (Backtrace*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Backtrace*) buildPartial {
  Backtrace* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (Backtrace_Builder*) mergeFrom:(Backtrace*) other {
  if (other == [Backtrace defaultInstance]) {
    return self;
  }
  if (other.framesArray.count > 0) {
    if (result.framesArray == nil) {
      result.framesArray = [[NSMutableArray alloc] initWithArray:other.framesArray];
    } else {
      [result.framesArray addObjectsFromArray:other.framesArray];
    }
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (Backtrace_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (Backtrace_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        Frame_Builder* subBuilder = [Frame builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFrames:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSMutableArray *)frames {
  return result.framesArray;
}
- (Frame*)framesAtIndex:(NSUInteger)index {
  return [result framesAtIndex:index];
}
- (Backtrace_Builder *)addFrames:(Frame*)value {
  if (result.framesArray == nil) {
    result.framesArray = [[NSMutableArray alloc]init];
  }
  [result.framesArray addObject:value];
  return self;
}
- (Backtrace_Builder *)setFramesArray:(NSArray *)array {
  result.framesArray = [[NSMutableArray alloc]init];
  return self;
}
- (Backtrace_Builder *)clearFrames {
  result.framesArray = nil;
  return self;
}
@end

@interface Response ()
@property Response_ResponseType type;
@property int64_t token;
@property (strong) NSMutableArray * responseArray;
@property (strong) Backtrace* backtrace;
@property (strong) Datum* profile;
@end

@implementation Response

- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasToken {
  return !!hasToken_;
}
- (void) setHasToken:(BOOL) value_ {
  hasToken_ = !!value_;
}
@synthesize token;
@synthesize responseArray;
@dynamic response;
- (BOOL) hasBacktrace {
  return !!hasBacktrace_;
}
- (void) setHasBacktrace:(BOOL) value_ {
  hasBacktrace_ = !!value_;
}
@synthesize backtrace;
- (BOOL) hasProfile {
  return !!hasProfile_;
}
- (void) setHasProfile:(BOOL) value_ {
  hasProfile_ = !!value_;
}
@synthesize profile;
- (id) init {
  if ((self = [super init])) {
    self.type = Response_ResponseTypeSuccessAtom;
    self.token = 0L;
    self.backtrace = [Backtrace defaultInstance];
    self.profile = [Datum defaultInstance];
  }
  return self;
}
static Response* defaultResponseInstance = nil;
+ (void) initialize {
  if (self == [Response class]) {
    defaultResponseInstance = [[Response alloc] init];
  }
}
+ (Response*) defaultInstance {
  return defaultResponseInstance;
}
- (Response*) defaultInstance {
  return defaultResponseInstance;
}
- (NSArray *)response {
  return responseArray;
}
- (Datum*)responseAtIndex:(NSUInteger)index {
  return [responseArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  for (Datum* element in self.response) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  if (self.hasProfile) {
    if (!self.profile.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasType) {
    [output writeEnum:1 value:self.type];
  }
  if (self.hasToken) {
    [output writeInt64:2 value:self.token];
  }
  for (Datum *element in self.responseArray) {
    [output writeMessage:3 value:element];
  }
  if (self.hasBacktrace) {
    [output writeMessage:4 value:self.backtrace];
  }
  if (self.hasProfile) {
    [output writeMessage:5 value:self.profile];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasType) {
    size_ += computeEnumSize(1, self.type);
  }
  if (self.hasToken) {
    size_ += computeInt64Size(2, self.token);
  }
  for (Datum *element in self.responseArray) {
    size_ += computeMessageSize(3, element);
  }
  if (self.hasBacktrace) {
    size_ += computeMessageSize(4, self.backtrace);
  }
  if (self.hasProfile) {
    size_ += computeMessageSize(5, self.profile);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Response*) parseFromData:(NSData*) data {
  return (Response*)[[[Response builder] mergeFromData:data] build];
}
+ (Response*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Response*)[[[Response builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Response*) parseFromInputStream:(NSInputStream*) input {
  return (Response*)[[[Response builder] mergeFromInputStream:input] build];
}
+ (Response*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Response*)[[[Response builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Response*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Response*)[[[Response builder] mergeFromCodedInputStream:input] build];
}
+ (Response*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Response*)[[[Response builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Response_Builder*) builder {
  return [[Response_Builder alloc] init];
}
+ (Response_Builder*) builderWithPrototype:(Response*) prototype {
  return [[Response builder] mergeFrom:prototype];
}
- (Response_Builder*) builder {
  return [Response builder];
}
- (Response_Builder*) toBuilder {
  return [Response builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasType) {
    [output appendFormat:@"%@%@: %d\n", indent, @"type", self.type];
  }
  if (self.hasToken) {
    [output appendFormat:@"%@%@: %@\n", indent, @"token", [NSNumber numberWithLongLong:self.token]];
  }
  for (Datum* element in self.responseArray) {
    [output appendFormat:@"%@%@ {\n", indent, @"response"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  if (self.hasBacktrace) {
    [output appendFormat:@"%@%@ {\n", indent, @"backtrace"];
    [self.backtrace writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  if (self.hasProfile) {
    [output appendFormat:@"%@%@ {\n", indent, @"profile"];
    [self.profile writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Response class]]) {
    return NO;
  }
  Response *otherMessage = other;
  return
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasToken == otherMessage.hasToken &&
      (!self.hasToken || self.token == otherMessage.token) &&
      [self.responseArray isEqualToArray:otherMessage.responseArray] &&
      self.hasBacktrace == otherMessage.hasBacktrace &&
      (!self.hasBacktrace || [self.backtrace isEqual:otherMessage.backtrace]) &&
      self.hasProfile == otherMessage.hasProfile &&
      (!self.hasProfile || [self.profile isEqual:otherMessage.profile]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasToken) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.token] hash];
  }
  for (Datum* element in self.responseArray) {
    hashCode = hashCode * 31 + [element hash];
  }
  if (self.hasBacktrace) {
    hashCode = hashCode * 31 + [self.backtrace hash];
  }
  if (self.hasProfile) {
    hashCode = hashCode * 31 + [self.profile hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL Response_ResponseTypeIsValidValue(Response_ResponseType value) {
  switch (value) {
    case Response_ResponseTypeSuccessAtom:
    case Response_ResponseTypeSuccessSequence:
    case Response_ResponseTypeSuccessPartial:
    case Response_ResponseTypeWaitComplete:
    case Response_ResponseTypeClientError:
    case Response_ResponseTypeCompileError:
    case Response_ResponseTypeRuntimeError:
      return YES;
    default:
      return NO;
  }
}
@interface Response_Builder()
@property (strong) Response* result;
@end

@implementation Response_Builder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[Response alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (Response_Builder*) clear {
  self.result = [[Response alloc] init];
  return self;
}
- (Response_Builder*) clone {
  return [Response builderWithPrototype:result];
}
- (Response*) defaultInstance {
  return [Response defaultInstance];
}
- (Response*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Response*) buildPartial {
  Response* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (Response_Builder*) mergeFrom:(Response*) other {
  if (other == [Response defaultInstance]) {
    return self;
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasToken) {
    [self setToken:other.token];
  }
  if (other.responseArray.count > 0) {
    if (result.responseArray == nil) {
      result.responseArray = [[NSMutableArray alloc] initWithArray:other.responseArray];
    } else {
      [result.responseArray addObjectsFromArray:other.responseArray];
    }
  }
  if (other.hasBacktrace) {
    [self mergeBacktrace:other.backtrace];
  }
  if (other.hasProfile) {
    [self mergeProfile:other.profile];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (Response_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (Response_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        int32_t value = [input readEnum];
        if (Response_ResponseTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 16: {
        [self setToken:[input readInt64]];
        break;
      }
      case 26: {
        Datum_Builder* subBuilder = [Datum builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addResponse:[subBuilder buildPartial]];
        break;
      }
      case 34: {
        Backtrace_Builder* subBuilder = [Backtrace builder];
        if (self.hasBacktrace) {
          [subBuilder mergeFrom:self.backtrace];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setBacktrace:[subBuilder buildPartial]];
        break;
      }
      case 42: {
        Datum_Builder* subBuilder = [Datum builder];
        if (self.hasProfile) {
          [subBuilder mergeFrom:self.profile];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setProfile:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasType {
  return result.hasType;
}
- (Response_ResponseType) type {
  return result.type;
}
- (Response_Builder*) setType:(Response_ResponseType) value {
  result.hasType = YES;
  result.type = value;
  return self;
}
- (Response_Builder*) clearType {
  result.hasType = NO;
  result.type = Response_ResponseTypeSuccessAtom;
  return self;
}
- (BOOL) hasToken {
  return result.hasToken;
}
- (int64_t) token {
  return result.token;
}
- (Response_Builder*) setToken:(int64_t) value {
  result.hasToken = YES;
  result.token = value;
  return self;
}
- (Response_Builder*) clearToken {
  result.hasToken = NO;
  result.token = 0L;
  return self;
}
- (NSMutableArray *)response {
  return result.responseArray;
}
- (Datum*)responseAtIndex:(NSUInteger)index {
  return [result responseAtIndex:index];
}
- (Response_Builder *)addResponse:(Datum*)value {
  if (result.responseArray == nil) {
    result.responseArray = [[NSMutableArray alloc]init];
  }
  [result.responseArray addObject:value];
  return self;
}
- (Response_Builder *)setResponseArray:(NSArray *)array {
  result.responseArray = [[NSMutableArray alloc]init];
  return self;
}
- (Response_Builder *)clearResponse {
  result.responseArray = nil;
  return self;
}
- (BOOL) hasBacktrace {
  return result.hasBacktrace;
}
- (Backtrace*) backtrace {
  return result.backtrace;
}
- (Response_Builder*) setBacktrace:(Backtrace*) value {
  result.hasBacktrace = YES;
  result.backtrace = value;
  return self;
}
- (Response_Builder*) setBacktraceBuilder:(Backtrace_Builder*) builderForValue {
  return [self setBacktrace:[builderForValue build]];
}
- (Response_Builder*) mergeBacktrace:(Backtrace*) value {
  if (result.hasBacktrace &&
      result.backtrace != [Backtrace defaultInstance]) {
    result.backtrace =
      [[[Backtrace builderWithPrototype:result.backtrace] mergeFrom:value] buildPartial];
  } else {
    result.backtrace = value;
  }
  result.hasBacktrace = YES;
  return self;
}
- (Response_Builder*) clearBacktrace {
  result.hasBacktrace = NO;
  result.backtrace = [Backtrace defaultInstance];
  return self;
}
- (BOOL) hasProfile {
  return result.hasProfile;
}
- (Datum*) profile {
  return result.profile;
}
- (Response_Builder*) setProfile:(Datum*) value {
  result.hasProfile = YES;
  result.profile = value;
  return self;
}
- (Response_Builder*) setProfileBuilder:(Datum_Builder*) builderForValue {
  return [self setProfile:[builderForValue build]];
}
- (Response_Builder*) mergeProfile:(Datum*) value {
  if (result.hasProfile &&
      result.profile != [Datum defaultInstance]) {
    result.profile =
      [[[Datum builderWithPrototype:result.profile] mergeFrom:value] buildPartial];
  } else {
    result.profile = value;
  }
  result.hasProfile = YES;
  return self;
}
- (Response_Builder*) clearProfile {
  result.hasProfile = NO;
  result.profile = [Datum defaultInstance];
  return self;
}
@end

@interface Datum ()
@property Datum_DatumType type;
@property BOOL rBool;
@property Float64 rNum;
@property (strong) NSString* rStr;
@property (strong) NSMutableArray * rArrayArray;
@property (strong) NSMutableArray * rObjectArray;
@end

@implementation Datum

- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasRBool {
  return !!hasRBool_;
}
- (void) setHasRBool:(BOOL) value_ {
  hasRBool_ = !!value_;
}
- (BOOL) rBool {
  return !!rBool_;
}
- (void) setRBool:(BOOL) value {
  rBool_ = !!value;
}
- (BOOL) hasRNum {
  return !!hasRNum_;
}
- (void) setHasRNum:(BOOL) value_ {
  hasRNum_ = !!value_;
}
@synthesize rNum;
- (BOOL) hasRStr {
  return !!hasRStr_;
}
- (void) setHasRStr:(BOOL) value_ {
  hasRStr_ = !!value_;
}
@synthesize rStr;
@synthesize rArrayArray;
@dynamic rArray;
@synthesize rObjectArray;
@dynamic rObject;
- (id) init {
  if ((self = [super init])) {
    self.type = Datum_DatumTypeRNull;
    self.rBool = NO;
    self.rNum = 0;
    self.rStr = @"";
  }
  return self;
}
static Datum* defaultDatumInstance = nil;
+ (void) initialize {
  if (self == [Datum class]) {
    defaultDatumInstance = [[Datum alloc] init];
  }
}
+ (Datum*) defaultInstance {
  return defaultDatumInstance;
}
- (Datum*) defaultInstance {
  return defaultDatumInstance;
}
- (NSArray *)rArray {
  return rArrayArray;
}
- (Datum*)rArrayAtIndex:(NSUInteger)index {
  return [rArrayArray objectAtIndex:index];
}
- (NSArray *)rObject {
  return rObjectArray;
}
- (Datum_AssocPair*)rObjectAtIndex:(NSUInteger)index {
  return [rObjectArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  for (Datum* element in self.rArray) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (Datum_AssocPair* element in self.rObject) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  if (!self.extensionsAreInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasType) {
    [output writeEnum:1 value:self.type];
  }
  if (self.hasRBool) {
    [output writeBool:2 value:self.rBool];
  }
  if (self.hasRNum) {
    [output writeDouble:3 value:self.rNum];
  }
  if (self.hasRStr) {
    [output writeString:4 value:self.rStr];
  }
  for (Datum *element in self.rArrayArray) {
    [output writeMessage:5 value:element];
  }
  for (Datum_AssocPair *element in self.rObjectArray) {
    [output writeMessage:6 value:element];
  }
  [self writeExtensionsToCodedOutputStream:output
                                      from:10000
                                        to:20001];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasType) {
    size_ += computeEnumSize(1, self.type);
  }
  if (self.hasRBool) {
    size_ += computeBoolSize(2, self.rBool);
  }
  if (self.hasRNum) {
    size_ += computeDoubleSize(3, self.rNum);
  }
  if (self.hasRStr) {
    size_ += computeStringSize(4, self.rStr);
  }
  for (Datum *element in self.rArrayArray) {
    size_ += computeMessageSize(5, element);
  }
  for (Datum_AssocPair *element in self.rObjectArray) {
    size_ += computeMessageSize(6, element);
  }
  size_ += [self extensionsSerializedSize];
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Datum*) parseFromData:(NSData*) data {
  return (Datum*)[[[Datum builder] mergeFromData:data] build];
}
+ (Datum*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Datum*)[[[Datum builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Datum*) parseFromInputStream:(NSInputStream*) input {
  return (Datum*)[[[Datum builder] mergeFromInputStream:input] build];
}
+ (Datum*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Datum*)[[[Datum builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Datum*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Datum*)[[[Datum builder] mergeFromCodedInputStream:input] build];
}
+ (Datum*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Datum*)[[[Datum builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Datum_Builder*) builder {
  return [[Datum_Builder alloc] init];
}
+ (Datum_Builder*) builderWithPrototype:(Datum*) prototype {
  return [[Datum builder] mergeFrom:prototype];
}
- (Datum_Builder*) builder {
  return [Datum builder];
}
- (Datum_Builder*) toBuilder {
  return [Datum builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasType) {
    [output appendFormat:@"%@%@: %d\n", indent, @"type", self.type];
  }
  if (self.hasRBool) {
    [output appendFormat:@"%@%@: %@\n", indent, @"rBool", [NSNumber numberWithBool:self.rBool]];
  }
  if (self.hasRNum) {
    [output appendFormat:@"%@%@: %@\n", indent, @"rNum", [NSNumber numberWithDouble:self.rNum]];
  }
  if (self.hasRStr) {
    [output appendFormat:@"%@%@: %@\n", indent, @"rStr", self.rStr];
  }
  for (Datum* element in self.rArrayArray) {
    [output appendFormat:@"%@%@ {\n", indent, @"rArray"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  for (Datum_AssocPair* element in self.rObjectArray) {
    [output appendFormat:@"%@%@ {\n", indent, @"rObject"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self writeExtensionDescriptionToMutableString:(NSMutableString*)output
                                            from:10000
                                              to:20001
                                      withIndent:indent];
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Datum class]]) {
    return NO;
  }
  Datum *otherMessage = other;
  return
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasRBool == otherMessage.hasRBool &&
      (!self.hasRBool || self.rBool == otherMessage.rBool) &&
      self.hasRNum == otherMessage.hasRNum &&
      (!self.hasRNum || self.rNum == otherMessage.rNum) &&
      self.hasRStr == otherMessage.hasRStr &&
      (!self.hasRStr || [self.rStr isEqual:otherMessage.rStr]) &&
      [self.rArrayArray isEqualToArray:otherMessage.rArrayArray] &&
      [self.rObjectArray isEqualToArray:otherMessage.rObjectArray] &&
      [self isEqualExtensionsInOther:otherMessage from:10000 to:20001] &&

      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasRBool) {
    hashCode = hashCode * 31 + [[NSNumber numberWithBool:self.rBool] hash];
  }
  if (self.hasRNum) {
    hashCode = hashCode * 31 + [[NSNumber numberWithDouble:self.rNum] hash];
  }
  if (self.hasRStr) {
    hashCode = hashCode * 31 + [self.rStr hash];
  }
  for (Datum* element in self.rArrayArray) {
    hashCode = hashCode * 31 + [element hash];
  }
  for (Datum_AssocPair* element in self.rObjectArray) {
    hashCode = hashCode * 31 + [element hash];
  }
  hashCode = hashCode * 31 + [self hashExtensionsFrom:10000 to:20001];
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL Datum_DatumTypeIsValidValue(Datum_DatumType value) {
  switch (value) {
    case Datum_DatumTypeRNull:
    case Datum_DatumTypeRBool:
    case Datum_DatumTypeRNum:
    case Datum_DatumTypeRStr:
    case Datum_DatumTypeRArray:
    case Datum_DatumTypeRObject:
    case Datum_DatumTypeRJson:
      return YES;
    default:
      return NO;
  }
}
@interface Datum_AssocPair ()
@property (strong) NSString* key;
@property (strong) Datum* val;
@end

@implementation Datum_AssocPair

- (BOOL) hasKey {
  return !!hasKey_;
}
- (void) setHasKey:(BOOL) value_ {
  hasKey_ = !!value_;
}
@synthesize key;
- (BOOL) hasVal {
  return !!hasVal_;
}
- (void) setHasVal:(BOOL) value_ {
  hasVal_ = !!value_;
}
@synthesize val;
- (id) init {
  if ((self = [super init])) {
    self.key = @"";
    self.val = [Datum defaultInstance];
  }
  return self;
}
static Datum_AssocPair* defaultDatum_AssocPairInstance = nil;
+ (void) initialize {
  if (self == [Datum_AssocPair class]) {
    defaultDatum_AssocPairInstance = [[Datum_AssocPair alloc] init];
  }
}
+ (Datum_AssocPair*) defaultInstance {
  return defaultDatum_AssocPairInstance;
}
- (Datum_AssocPair*) defaultInstance {
  return defaultDatum_AssocPairInstance;
}
- (BOOL) isInitialized {
  if (self.hasVal) {
    if (!self.val.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasKey) {
    [output writeString:1 value:self.key];
  }
  if (self.hasVal) {
    [output writeMessage:2 value:self.val];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasKey) {
    size_ += computeStringSize(1, self.key);
  }
  if (self.hasVal) {
    size_ += computeMessageSize(2, self.val);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Datum_AssocPair*) parseFromData:(NSData*) data {
  return (Datum_AssocPair*)[[[Datum_AssocPair builder] mergeFromData:data] build];
}
+ (Datum_AssocPair*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Datum_AssocPair*)[[[Datum_AssocPair builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Datum_AssocPair*) parseFromInputStream:(NSInputStream*) input {
  return (Datum_AssocPair*)[[[Datum_AssocPair builder] mergeFromInputStream:input] build];
}
+ (Datum_AssocPair*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Datum_AssocPair*)[[[Datum_AssocPair builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Datum_AssocPair*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Datum_AssocPair*)[[[Datum_AssocPair builder] mergeFromCodedInputStream:input] build];
}
+ (Datum_AssocPair*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Datum_AssocPair*)[[[Datum_AssocPair builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Datum_AssocPair_Builder*) builder {
  return [[Datum_AssocPair_Builder alloc] init];
}
+ (Datum_AssocPair_Builder*) builderWithPrototype:(Datum_AssocPair*) prototype {
  return [[Datum_AssocPair builder] mergeFrom:prototype];
}
- (Datum_AssocPair_Builder*) builder {
  return [Datum_AssocPair builder];
}
- (Datum_AssocPair_Builder*) toBuilder {
  return [Datum_AssocPair builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasKey) {
    [output appendFormat:@"%@%@: %@\n", indent, @"key", self.key];
  }
  if (self.hasVal) {
    [output appendFormat:@"%@%@ {\n", indent, @"val"];
    [self.val writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Datum_AssocPair class]]) {
    return NO;
  }
  Datum_AssocPair *otherMessage = other;
  return
      self.hasKey == otherMessage.hasKey &&
      (!self.hasKey || [self.key isEqual:otherMessage.key]) &&
      self.hasVal == otherMessage.hasVal &&
      (!self.hasVal || [self.val isEqual:otherMessage.val]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  if (self.hasKey) {
    hashCode = hashCode * 31 + [self.key hash];
  }
  if (self.hasVal) {
    hashCode = hashCode * 31 + [self.val hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface Datum_AssocPair_Builder()
@property (strong) Datum_AssocPair* result;
@end

@implementation Datum_AssocPair_Builder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[Datum_AssocPair alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (Datum_AssocPair_Builder*) clear {
  self.result = [[Datum_AssocPair alloc] init];
  return self;
}
- (Datum_AssocPair_Builder*) clone {
  return [Datum_AssocPair builderWithPrototype:result];
}
- (Datum_AssocPair*) defaultInstance {
  return [Datum_AssocPair defaultInstance];
}
- (Datum_AssocPair*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Datum_AssocPair*) buildPartial {
  Datum_AssocPair* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (Datum_AssocPair_Builder*) mergeFrom:(Datum_AssocPair*) other {
  if (other == [Datum_AssocPair defaultInstance]) {
    return self;
  }
  if (other.hasKey) {
    [self setKey:other.key];
  }
  if (other.hasVal) {
    [self mergeVal:other.val];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (Datum_AssocPair_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (Datum_AssocPair_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setKey:[input readString]];
        break;
      }
      case 18: {
        Datum_Builder* subBuilder = [Datum builder];
        if (self.hasVal) {
          [subBuilder mergeFrom:self.val];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setVal:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasKey {
  return result.hasKey;
}
- (NSString*) key {
  return result.key;
}
- (Datum_AssocPair_Builder*) setKey:(NSString*) value {
  result.hasKey = YES;
  result.key = value;
  return self;
}
- (Datum_AssocPair_Builder*) clearKey {
  result.hasKey = NO;
  result.key = @"";
  return self;
}
- (BOOL) hasVal {
  return result.hasVal;
}
- (Datum*) val {
  return result.val;
}
- (Datum_AssocPair_Builder*) setVal:(Datum*) value {
  result.hasVal = YES;
  result.val = value;
  return self;
}
- (Datum_AssocPair_Builder*) setValBuilder:(Datum_Builder*) builderForValue {
  return [self setVal:[builderForValue build]];
}
- (Datum_AssocPair_Builder*) mergeVal:(Datum*) value {
  if (result.hasVal &&
      result.val != [Datum defaultInstance]) {
    result.val =
      [[[Datum builderWithPrototype:result.val] mergeFrom:value] buildPartial];
  } else {
    result.val = value;
  }
  result.hasVal = YES;
  return self;
}
- (Datum_AssocPair_Builder*) clearVal {
  result.hasVal = NO;
  result.val = [Datum defaultInstance];
  return self;
}
@end

@interface Datum_Builder()
@property (strong) Datum* result;
@end

@implementation Datum_Builder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[Datum alloc] init];
  }
  return self;
}
- (PBExtendableMessage*) internalGetResult {
  return result;
}
- (Datum_Builder*) clear {
  self.result = [[Datum alloc] init];
  return self;
}
- (Datum_Builder*) clone {
  return [Datum builderWithPrototype:result];
}
- (Datum*) defaultInstance {
  return [Datum defaultInstance];
}
- (Datum*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Datum*) buildPartial {
  Datum* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (Datum_Builder*) mergeFrom:(Datum*) other {
  if (other == [Datum defaultInstance]) {
    return self;
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasRBool) {
    [self setRBool:other.rBool];
  }
  if (other.hasRNum) {
    [self setRNum:other.rNum];
  }
  if (other.hasRStr) {
    [self setRStr:other.rStr];
  }
  if (other.rArrayArray.count > 0) {
    if (result.rArrayArray == nil) {
      result.rArrayArray = [[NSMutableArray alloc] initWithArray:other.rArrayArray];
    } else {
      [result.rArrayArray addObjectsFromArray:other.rArrayArray];
    }
  }
  if (other.rObjectArray.count > 0) {
    if (result.rObjectArray == nil) {
      result.rObjectArray = [[NSMutableArray alloc] initWithArray:other.rObjectArray];
    } else {
      [result.rObjectArray addObjectsFromArray:other.rObjectArray];
    }
  }
  [self mergeExtensionFields:other];
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (Datum_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (Datum_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        int32_t value = [input readEnum];
        if (Datum_DatumTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 16: {
        [self setRBool:[input readBool]];
        break;
      }
      case 25: {
        [self setRNum:[input readDouble]];
        break;
      }
      case 34: {
        [self setRStr:[input readString]];
        break;
      }
      case 42: {
        Datum_Builder* subBuilder = [Datum builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addRArray:[subBuilder buildPartial]];
        break;
      }
      case 50: {
        Datum_AssocPair_Builder* subBuilder = [Datum_AssocPair builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addRObject:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasType {
  return result.hasType;
}
- (Datum_DatumType) type {
  return result.type;
}
- (Datum_Builder*) setType:(Datum_DatumType) value {
  result.hasType = YES;
  result.type = value;
  return self;
}
- (Datum_Builder*) clearType {
  result.hasType = NO;
  result.type = Datum_DatumTypeRNull;
  return self;
}
- (BOOL) hasRBool {
  return result.hasRBool;
}
- (BOOL) rBool {
  return result.rBool;
}
- (Datum_Builder*) setRBool:(BOOL) value {
  result.hasRBool = YES;
  result.rBool = value;
  return self;
}
- (Datum_Builder*) clearRBool {
  result.hasRBool = NO;
  result.rBool = NO;
  return self;
}
- (BOOL) hasRNum {
  return result.hasRNum;
}
- (Float64) rNum {
  return result.rNum;
}
- (Datum_Builder*) setRNum:(Float64) value {
  result.hasRNum = YES;
  result.rNum = value;
  return self;
}
- (Datum_Builder*) clearRNum {
  result.hasRNum = NO;
  result.rNum = 0;
  return self;
}
- (BOOL) hasRStr {
  return result.hasRStr;
}
- (NSString*) rStr {
  return result.rStr;
}
- (Datum_Builder*) setRStr:(NSString*) value {
  result.hasRStr = YES;
  result.rStr = value;
  return self;
}
- (Datum_Builder*) clearRStr {
  result.hasRStr = NO;
  result.rStr = @"";
  return self;
}
- (NSMutableArray *)rArray {
  return result.rArrayArray;
}
- (Datum*)rArrayAtIndex:(NSUInteger)index {
  return [result rArrayAtIndex:index];
}
- (Datum_Builder *)addRArray:(Datum*)value {
  if (result.rArrayArray == nil) {
    result.rArrayArray = [[NSMutableArray alloc]init];
  }
  [result.rArrayArray addObject:value];
  return self;
}
- (Datum_Builder *)setRArrayArray:(NSArray *)array {
  result.rArrayArray = [[NSMutableArray alloc]init];
  return self;
}
- (Datum_Builder *)clearRArray {
  result.rArrayArray = nil;
  return self;
}
- (NSMutableArray *)rObject {
  return result.rObjectArray;
}
- (Datum_AssocPair*)rObjectAtIndex:(NSUInteger)index {
  return [result rObjectAtIndex:index];
}
- (Datum_Builder *)addRObject:(Datum_AssocPair*)value {
  if (result.rObjectArray == nil) {
    result.rObjectArray = [[NSMutableArray alloc]init];
  }
  [result.rObjectArray addObject:value];
  return self;
}
- (Datum_Builder *)setRObjectArray:(NSArray *)array {
  result.rObjectArray = [[NSMutableArray alloc]init];
  return self;
}
- (Datum_Builder *)clearRObject {
  result.rObjectArray = nil;
  return self;
}
@end

@interface Term ()
@property Term_TermType type;
@property (strong) Datum* datum;
@property (strong) NSMutableArray * argsArray;
@property (strong) NSMutableArray * optargsArray;
@end

@implementation Term

- (BOOL) hasType {
  return !!hasType_;
}
- (void) setHasType:(BOOL) value_ {
  hasType_ = !!value_;
}
@synthesize type;
- (BOOL) hasDatum {
  return !!hasDatum_;
}
- (void) setHasDatum:(BOOL) value_ {
  hasDatum_ = !!value_;
}
@synthesize datum;
@synthesize argsArray;
@dynamic args;
@synthesize optargsArray;
@dynamic optargs;
- (id) init {
  if ((self = [super init])) {
    self.type = Term_TermTypeDatum;
    self.datum = [Datum defaultInstance];
  }
  return self;
}
static Term* defaultTermInstance = nil;
+ (void) initialize {
  if (self == [Term class]) {
    defaultTermInstance = [[Term alloc] init];
  }
}
+ (Term*) defaultInstance {
  return defaultTermInstance;
}
- (Term*) defaultInstance {
  return defaultTermInstance;
}
- (NSArray *)args {
  return argsArray;
}
- (Term*)argsAtIndex:(NSUInteger)index {
  return [argsArray objectAtIndex:index];
}
- (NSArray *)optargs {
  return optargsArray;
}
- (Term_AssocPair*)optargsAtIndex:(NSUInteger)index {
  return [optargsArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  if (self.hasDatum) {
    if (!self.datum.isInitialized) {
      return NO;
    }
  }
  for (Term* element in self.args) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (Term_AssocPair* element in self.optargs) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  if (!self.extensionsAreInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasType) {
    [output writeEnum:1 value:self.type];
  }
  if (self.hasDatum) {
    [output writeMessage:2 value:self.datum];
  }
  for (Term *element in self.argsArray) {
    [output writeMessage:3 value:element];
  }
  for (Term_AssocPair *element in self.optargsArray) {
    [output writeMessage:4 value:element];
  }
  [self writeExtensionsToCodedOutputStream:output
                                      from:10000
                                        to:20001];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasType) {
    size_ += computeEnumSize(1, self.type);
  }
  if (self.hasDatum) {
    size_ += computeMessageSize(2, self.datum);
  }
  for (Term *element in self.argsArray) {
    size_ += computeMessageSize(3, element);
  }
  for (Term_AssocPair *element in self.optargsArray) {
    size_ += computeMessageSize(4, element);
  }
  size_ += [self extensionsSerializedSize];
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Term*) parseFromData:(NSData*) data {
  return (Term*)[[[Term builder] mergeFromData:data] build];
}
+ (Term*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Term*)[[[Term builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Term*) parseFromInputStream:(NSInputStream*) input {
  return (Term*)[[[Term builder] mergeFromInputStream:input] build];
}
+ (Term*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Term*)[[[Term builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Term*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Term*)[[[Term builder] mergeFromCodedInputStream:input] build];
}
+ (Term*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Term*)[[[Term builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Term_Builder*) builder {
  return [[Term_Builder alloc] init];
}
+ (Term_Builder*) builderWithPrototype:(Term*) prototype {
  return [[Term builder] mergeFrom:prototype];
}
- (Term_Builder*) builder {
  return [Term builder];
}
- (Term_Builder*) toBuilder {
  return [Term builderWithPrototype:self];
}
+ (NSString*) typeToString:(Term_TermType) type {
    switch (type) {
        case Term_TermTypeDatum: return @"datum";
        case Term_TermTypeMakeArray: return @"make_array";
        case Term_TermTypeMakeObj: return @"make_obj";
        case Term_TermTypeVar: return @"type_var";
        case Term_TermTypeJavascript: return @"javascript";
        case Term_TermTypeError: return @"error";
        case Term_TermTypeImplicitVar: return @"ImplicitVar";
        case Term_TermTypeDb: return @"Db";
        case Term_TermTypeTable: return @"Table";
        case Term_TermTypeGet: return @"Get";
        case Term_TermTypeGetAll: return @"GetAll";
        case Term_TermTypeEq: return @"Eq";
        case Term_TermTypeNe: return @"Ne";
        case Term_TermTypeLt: return @"Lt";
        case Term_TermTypeLe: return @"Le";
        case Term_TermTypeGt: return @"Gt";
        case Term_TermTypeGe: return @"Ge";
        case Term_TermTypeNot: return @"Not";
        case Term_TermTypeAdd: return @"Add";
        case Term_TermTypeSub: return @"Sub";
        case Term_TermTypeMul: return @"Mul";
        case Term_TermTypeDiv: return @"Div";
        case Term_TermTypeMod: return @"Mod";
        case Term_TermTypeAppend: return @"Append";
        case Term_TermTypePrepend: return @"Prepend";
        case Term_TermTypeDifference: return @"Difference";
        case Term_TermTypeSetInsert: return @"SetInsert";
        case Term_TermTypeSetIntersection: return @"SetIntersection";
        case Term_TermTypeSetUnion: return @"SetUnion";
        case Term_TermTypeSetDifference: return @"SetDifference";
        case Term_TermTypeSlice: return @"Slice";
        case Term_TermTypeSkip: return @"Skip";
        case Term_TermTypeLimit: return @"Limit";
        case Term_TermTypeIndexesOf: return @"IndexesOf";
        case Term_TermTypeContains: return @"Contains";
        case Term_TermTypeGetField: return @"GetField";
        case Term_TermTypeKeys: return @"Keys";
        case Term_TermTypeHasFields: return @"HasFields";
        case Term_TermTypeWithFields: return @"WithFields";
        case Term_TermTypePluck: return @"Pluck";
        case Term_TermTypeWithout: return @"Without";
        case Term_TermTypeMerge: return @"Merge";
        case Term_TermTypeBetween: return @"Between";
        case Term_TermTypeReduce: return @"Reduce";
        case Term_TermTypeMap: return @"Map";
        case Term_TermTypeFilter: return @"Filter";
        case Term_TermTypeConcatmap: return @"Concatmap";
        case Term_TermTypeOrderby: return @"Orderby";
        case Term_TermTypeDistinct: return @"Distinct";
        case Term_TermTypeCount: return @"Count";
        case Term_TermTypeIsEmpty: return @"IsEmpty";
        case Term_TermTypeUnion: return @"Union";
        case Term_TermTypeNth: return @"Nth";
        case Term_TermTypeGroupedMapReduce: return @"GroupedMapReduce";
        case Term_TermTypeGroupby: return @"Groupby";
        case Term_TermTypeInnerJoin: return @"InnerJoin";
        case Term_TermTypeOuterJoin: return @"OuterJoin";
        case Term_TermTypeEqJoin: return @"EqJoin";
        case Term_TermTypeZip: return @"Zip";
        case Term_TermTypeInsertAt: return @"InsertAt";
        case Term_TermTypeDeleteAt: return @"DeleteAt";
        case Term_TermTypeChangeAt: return @"ChangeAt";
        case Term_TermTypeSpliceAt: return @"SpliceAt";
        case Term_TermTypeCoerceTo: return @"CoerceTo";
        case Term_TermTypeTypeof: return @"Typeof";
        case Term_TermTypeUpdate: return @"Update";
        case Term_TermTypeDelete: return @"Delete";
        case Term_TermTypeReplace: return @"Replace";
        case Term_TermTypeInsert: return @"Insert";
        case Term_TermTypeDbCreate: return @"DbCreate";
        case Term_TermTypeDbDrop: return @"DbDrop";
        case Term_TermTypeDbList: return @"DbList";
        case Term_TermTypeTableCreate: return @"TableCreate";
        case Term_TermTypeTableDrop: return @"TableDrop";
        case Term_TermTypeTableList: return @"TableList";
        case Term_TermTypeSync: return @"Sync";
        case Term_TermTypeIndexCreate: return @"IndexCreate";
        case Term_TermTypeIndexDrop: return @"IndexDrop";
        case Term_TermTypeIndexList: return @"IndexList";
        case Term_TermTypeIndexStatus: return @"IndexStatus";
        case Term_TermTypeIndexWait: return @"IndexWait";
        case Term_TermTypeFuncall: return @"Funcall";
        case Term_TermTypeBranch: return @"Branch";
        case Term_TermTypeAny: return @"Any";
        case Term_TermTypeAll: return @"All";
        case Term_TermTypeForeach: return @"Foreach";
        case Term_TermTypeFunc: return @"Func";
        case Term_TermTypeAsc: return @"Asc";
        case Term_TermTypeDesc: return @"Desc";
        case Term_TermTypeInfo: return @"Info";
        case Term_TermTypeMatch: return @"Match";
        case Term_TermTypeUpcase: return @"Upcase";
        case Term_TermTypeDowncase: return @"Downcase";
        case Term_TermTypeSample: return @"Sample";
        case Term_TermTypeDefault: return @"Default";
        case Term_TermTypeJson: return @"Json";
        case Term_TermTypeIso8601: return @"Iso8601";
        case Term_TermTypeToIso8601: return @"ToIso8601";
        case Term_TermTypeEpochTime: return @"EpochTime";
        case Term_TermTypeToEpochTime: return @"ToEpochTime";
        case Term_TermTypeNow: return @"Now";
        case Term_TermTypeInTimezone: return @"InTimezone";
        case Term_TermTypeDuring: return @"During";
        case Term_TermTypeDate: return @"Date";
        case Term_TermTypeTimeOfDay: return @"TimeOfDay";
        case Term_TermTypeTimezone: return @"Timezone";
        case Term_TermTypeYear: return @"Year";
        case Term_TermTypeMonth: return @"Month";
        case Term_TermTypeDay: return @"Day";
        case Term_TermTypeDayOfWeek: return @"DayOfWeek";
        case Term_TermTypeDayOfYear: return @"DayOfYear";
        case Term_TermTypeHours: return @"Hours";
        case Term_TermTypeMinutes: return @"Minutes";
        case Term_TermTypeSeconds: return @"Seconds";
        case Term_TermTypeTime: return @"Time";
        case Term_TermTypeMonday: return @"Monday";
        case Term_TermTypeTuesday: return @"Tuesday";
        case Term_TermTypeWednesday: return @"Wednesday";
        case Term_TermTypeThursday: return @"Thursday";
        case Term_TermTypeFriday: return @"Friday";
        case Term_TermTypeSaturday: return @"Saturday";
        case Term_TermTypeSunday: return @"Sunday";
        case Term_TermTypeJanuary: return @"January";
        case Term_TermTypeFebruary: return @"February";
        case Term_TermTypeMarch: return @"March";
        case Term_TermTypeApril: return @"April";
        case Term_TermTypeMay: return @"May";
        case Term_TermTypeJune: return @"June";
        case Term_TermTypeJuly: return @"July";
        case Term_TermTypeAugust: return @"August";
        case Term_TermTypeSeptember: return @"September";
        case Term_TermTypeOctober: return @"october";
        case Term_TermTypeNovember: return @"november";
        case Term_TermTypeDecember: return @"december";
        case Term_TermTypeLiteral: return @"literal";
    }
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasType) {
      [output appendFormat:@"%@%@: %@\n", indent, @"type", [Term typeToString: self.type]];
  }
  if (self.hasDatum) {
    [output appendFormat:@"%@%@ {\n", indent, @"datum"];
    [self.datum writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  for (Term* element in self.argsArray) {
    [output appendFormat:@"%@%@ {\n", indent, @"args"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  for (Term_AssocPair* element in self.optargsArray) {
    [output appendFormat:@"%@%@ {\n", indent, @"optargs"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self writeExtensionDescriptionToMutableString:(NSMutableString*)output
                                            from:10000
                                              to:20001
                                      withIndent:indent];
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Term class]]) {
    return NO;
  }
  Term *otherMessage = other;
  return
      self.hasType == otherMessage.hasType &&
      (!self.hasType || self.type == otherMessage.type) &&
      self.hasDatum == otherMessage.hasDatum &&
      (!self.hasDatum || [self.datum isEqual:otherMessage.datum]) &&
      [self.argsArray isEqualToArray:otherMessage.argsArray] &&
      [self.optargsArray isEqualToArray:otherMessage.optargsArray] &&
      [self isEqualExtensionsInOther:otherMessage from:10000 to:20001] &&

      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  if (self.hasType) {
    hashCode = hashCode * 31 + self.type;
  }
  if (self.hasDatum) {
    hashCode = hashCode * 31 + [self.datum hash];
  }
  for (Term* element in self.argsArray) {
    hashCode = hashCode * 31 + [element hash];
  }
  for (Term_AssocPair* element in self.optargsArray) {
    hashCode = hashCode * 31 + [element hash];
  }
  hashCode = hashCode * 31 + [self hashExtensionsFrom:10000 to:20001];
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

BOOL Term_TermTypeIsValidValue(Term_TermType value) {
  switch (value) {
    case Term_TermTypeDatum:
    case Term_TermTypeMakeArray:
    case Term_TermTypeMakeObj:
    case Term_TermTypeVar:
    case Term_TermTypeJavascript:
    case Term_TermTypeError:
    case Term_TermTypeImplicitVar:
    case Term_TermTypeDb:
    case Term_TermTypeTable:
    case Term_TermTypeGet:
    case Term_TermTypeGetAll:
    case Term_TermTypeEq:
    case Term_TermTypeNe:
    case Term_TermTypeLt:
    case Term_TermTypeLe:
    case Term_TermTypeGt:
    case Term_TermTypeGe:
    case Term_TermTypeNot:
    case Term_TermTypeAdd:
    case Term_TermTypeSub:
    case Term_TermTypeMul:
    case Term_TermTypeDiv:
    case Term_TermTypeMod:
    case Term_TermTypeAppend:
    case Term_TermTypePrepend:
    case Term_TermTypeDifference:
    case Term_TermTypeSetInsert:
    case Term_TermTypeSetIntersection:
    case Term_TermTypeSetUnion:
    case Term_TermTypeSetDifference:
    case Term_TermTypeSlice:
    case Term_TermTypeSkip:
    case Term_TermTypeLimit:
    case Term_TermTypeIndexesOf:
    case Term_TermTypeContains:
    case Term_TermTypeGetField:
    case Term_TermTypeKeys:
    case Term_TermTypeHasFields:
    case Term_TermTypeWithFields:
    case Term_TermTypePluck:
    case Term_TermTypeWithout:
    case Term_TermTypeMerge:
    case Term_TermTypeBetween:
    case Term_TermTypeReduce:
    case Term_TermTypeMap:
    case Term_TermTypeFilter:
    case Term_TermTypeConcatmap:
    case Term_TermTypeOrderby:
    case Term_TermTypeDistinct:
    case Term_TermTypeCount:
    case Term_TermTypeIsEmpty:
    case Term_TermTypeUnion:
    case Term_TermTypeNth:
    case Term_TermTypeGroupedMapReduce:
    case Term_TermTypeGroupby:
    case Term_TermTypeInnerJoin:
    case Term_TermTypeOuterJoin:
    case Term_TermTypeEqJoin:
    case Term_TermTypeZip:
    case Term_TermTypeInsertAt:
    case Term_TermTypeDeleteAt:
    case Term_TermTypeChangeAt:
    case Term_TermTypeSpliceAt:
    case Term_TermTypeCoerceTo:
    case Term_TermTypeTypeof:
    case Term_TermTypeUpdate:
    case Term_TermTypeDelete:
    case Term_TermTypeReplace:
    case Term_TermTypeInsert:
    case Term_TermTypeDbCreate:
    case Term_TermTypeDbDrop:
    case Term_TermTypeDbList:
    case Term_TermTypeTableCreate:
    case Term_TermTypeTableDrop:
    case Term_TermTypeTableList:
    case Term_TermTypeSync:
    case Term_TermTypeIndexCreate:
    case Term_TermTypeIndexDrop:
    case Term_TermTypeIndexList:
    case Term_TermTypeIndexStatus:
    case Term_TermTypeIndexWait:
    case Term_TermTypeFuncall:
    case Term_TermTypeBranch:
    case Term_TermTypeAny:
    case Term_TermTypeAll:
    case Term_TermTypeForeach:
    case Term_TermTypeFunc:
    case Term_TermTypeAsc:
    case Term_TermTypeDesc:
    case Term_TermTypeInfo:
    case Term_TermTypeMatch:
    case Term_TermTypeUpcase:
    case Term_TermTypeDowncase:
    case Term_TermTypeSample:
    case Term_TermTypeDefault:
    case Term_TermTypeJson:
    case Term_TermTypeIso8601:
    case Term_TermTypeToIso8601:
    case Term_TermTypeEpochTime:
    case Term_TermTypeToEpochTime:
    case Term_TermTypeNow:
    case Term_TermTypeInTimezone:
    case Term_TermTypeDuring:
    case Term_TermTypeDate:
    case Term_TermTypeTimeOfDay:
    case Term_TermTypeTimezone:
    case Term_TermTypeYear:
    case Term_TermTypeMonth:
    case Term_TermTypeDay:
    case Term_TermTypeDayOfWeek:
    case Term_TermTypeDayOfYear:
    case Term_TermTypeHours:
    case Term_TermTypeMinutes:
    case Term_TermTypeSeconds:
    case Term_TermTypeTime:
    case Term_TermTypeMonday:
    case Term_TermTypeTuesday:
    case Term_TermTypeWednesday:
    case Term_TermTypeThursday:
    case Term_TermTypeFriday:
    case Term_TermTypeSaturday:
    case Term_TermTypeSunday:
    case Term_TermTypeJanuary:
    case Term_TermTypeFebruary:
    case Term_TermTypeMarch:
    case Term_TermTypeApril:
    case Term_TermTypeMay:
    case Term_TermTypeJune:
    case Term_TermTypeJuly:
    case Term_TermTypeAugust:
    case Term_TermTypeSeptember:
    case Term_TermTypeOctober:
    case Term_TermTypeNovember:
    case Term_TermTypeDecember:
    case Term_TermTypeLiteral:
      return YES;
    default:
      return NO;
  }
}
@interface Term_AssocPair ()
@property (strong) NSString* key;
@property (strong) Term* val;
@end

@implementation Term_AssocPair

- (BOOL) hasKey {
  return !!hasKey_;
}
- (void) setHasKey:(BOOL) value_ {
  hasKey_ = !!value_;
}
@synthesize key;
- (BOOL) hasVal {
  return !!hasVal_;
}
- (void) setHasVal:(BOOL) value_ {
  hasVal_ = !!value_;
}
@synthesize val;
- (id) init {
  if ((self = [super init])) {
    self.key = @"";
    self.val = [Term defaultInstance];
  }
  return self;
}
static Term_AssocPair* defaultTerm_AssocPairInstance = nil;
+ (void) initialize {
  if (self == [Term_AssocPair class]) {
    defaultTerm_AssocPairInstance = [[Term_AssocPair alloc] init];
  }
}
+ (Term_AssocPair*) defaultInstance {
  return defaultTerm_AssocPairInstance;
}
- (Term_AssocPair*) defaultInstance {
  return defaultTerm_AssocPairInstance;
}
- (BOOL) isInitialized {
  if (self.hasVal) {
    if (!self.val.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasKey) {
    [output writeString:1 value:self.key];
  }
  if (self.hasVal) {
    [output writeMessage:2 value:self.val];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasKey) {
    size_ += computeStringSize(1, self.key);
  }
  if (self.hasVal) {
    size_ += computeMessageSize(2, self.val);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Term_AssocPair*) parseFromData:(NSData*) data {
  return (Term_AssocPair*)[[[Term_AssocPair builder] mergeFromData:data] build];
}
+ (Term_AssocPair*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Term_AssocPair*)[[[Term_AssocPair builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Term_AssocPair*) parseFromInputStream:(NSInputStream*) input {
  return (Term_AssocPair*)[[[Term_AssocPair builder] mergeFromInputStream:input] build];
}
+ (Term_AssocPair*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Term_AssocPair*)[[[Term_AssocPair builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Term_AssocPair*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Term_AssocPair*)[[[Term_AssocPair builder] mergeFromCodedInputStream:input] build];
}
+ (Term_AssocPair*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Term_AssocPair*)[[[Term_AssocPair builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Term_AssocPair_Builder*) builder {
  return [[Term_AssocPair_Builder alloc] init];
}
+ (Term_AssocPair_Builder*) builderWithPrototype:(Term_AssocPair*) prototype {
  return [[Term_AssocPair builder] mergeFrom:prototype];
}
- (Term_AssocPair_Builder*) builder {
  return [Term_AssocPair builder];
}
- (Term_AssocPair_Builder*) toBuilder {
  return [Term_AssocPair builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasKey) {
    [output appendFormat:@"%@%@: %@\n", indent, @"key", self.key];
  }
  if (self.hasVal) {
    [output appendFormat:@"%@%@ {\n", indent, @"val"];
    [self.val writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Term_AssocPair class]]) {
    return NO;
  }
  Term_AssocPair *otherMessage = other;
  return
      self.hasKey == otherMessage.hasKey &&
      (!self.hasKey || [self.key isEqual:otherMessage.key]) &&
      self.hasVal == otherMessage.hasVal &&
      (!self.hasVal || [self.val isEqual:otherMessage.val]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  if (self.hasKey) {
    hashCode = hashCode * 31 + [self.key hash];
  }
  if (self.hasVal) {
    hashCode = hashCode * 31 + [self.val hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface Term_AssocPair_Builder()
@property (strong) Term_AssocPair* result;
@end

@implementation Term_AssocPair_Builder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[Term_AssocPair alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (Term_AssocPair_Builder*) clear {
  self.result = [[Term_AssocPair alloc] init];
  return self;
}
- (Term_AssocPair_Builder*) clone {
  return [Term_AssocPair builderWithPrototype:result];
}
- (Term_AssocPair*) defaultInstance {
  return [Term_AssocPair defaultInstance];
}
- (Term_AssocPair*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Term_AssocPair*) buildPartial {
  Term_AssocPair* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (Term_AssocPair_Builder*) mergeFrom:(Term_AssocPair*) other {
  if (other == [Term_AssocPair defaultInstance]) {
    return self;
  }
  if (other.hasKey) {
    [self setKey:other.key];
  }
  if (other.hasVal) {
    [self mergeVal:other.val];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (Term_AssocPair_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (Term_AssocPair_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setKey:[input readString]];
        break;
      }
      case 18: {
        Term_Builder* subBuilder = [Term builder];
        if (self.hasVal) {
          [subBuilder mergeFrom:self.val];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setVal:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasKey {
  return result.hasKey;
}
- (NSString*) key {
  return result.key;
}
- (Term_AssocPair_Builder*) setKey:(NSString*) value {
  result.hasKey = YES;
  result.key = value;
  return self;
}
- (Term_AssocPair_Builder*) clearKey {
  result.hasKey = NO;
  result.key = @"";
  return self;
}
- (BOOL) hasVal {
  return result.hasVal;
}
- (Term*) val {
  return result.val;
}
- (Term_AssocPair_Builder*) setVal:(Term*) value {
  result.hasVal = YES;
  result.val = value;
  return self;
}
- (Term_AssocPair_Builder*) setValBuilder:(Term_Builder*) builderForValue {
  return [self setVal:[builderForValue build]];
}
- (Term_AssocPair_Builder*) mergeVal:(Term*) value {
  if (result.hasVal &&
      result.val != [Term defaultInstance]) {
    result.val =
      [[[Term builderWithPrototype:result.val] mergeFrom:value] buildPartial];
  } else {
    result.val = value;
  }
  result.hasVal = YES;
  return self;
}
- (Term_AssocPair_Builder*) clearVal {
  result.hasVal = NO;
  result.val = [Term defaultInstance];
  return self;
}
@end

@interface Term_Builder()
@property (strong) Term* result;
@end

@implementation Term_Builder
@synthesize result;
- (id) init {
  if ((self = [super init])) {
    self.result = [[Term alloc] init];
  }
  return self;
}
- (PBExtendableMessage*) internalGetResult {
  return result;
}
- (Term_Builder*) clear {
  self.result = [[Term alloc] init];
  return self;
}
- (Term_Builder*) clone {
  return [Term builderWithPrototype:result];
}
- (Term*) defaultInstance {
  return [Term defaultInstance];
}
- (Term*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Term*) buildPartial {
  Term* returnMe = result;
  self.result = nil;
  return returnMe;
}
- (Term_Builder*) mergeFrom:(Term*) other {
  if (other == [Term defaultInstance]) {
    return self;
  }
  if (other.hasType) {
    [self setType:other.type];
  }
  if (other.hasDatum) {
    [self mergeDatum:other.datum];
  }
  if (other.argsArray.count > 0) {
    if (result.argsArray == nil) {
      result.argsArray = [[NSMutableArray alloc] initWithArray:other.argsArray];
    } else {
      [result.argsArray addObjectsFromArray:other.argsArray];
    }
  }
  if (other.optargsArray.count > 0) {
    if (result.optargsArray == nil) {
      result.optargsArray = [[NSMutableArray alloc] initWithArray:other.optargsArray];
    } else {
      [result.optargsArray addObjectsFromArray:other.optargsArray];
    }
  }
  [self mergeExtensionFields:other];
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (Term_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (Term_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        int32_t value = [input readEnum];
        if (Term_TermTypeIsValidValue(value)) {
          [self setType:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 18: {
        Datum_Builder* subBuilder = [Datum builder];
        if (self.hasDatum) {
          [subBuilder mergeFrom:self.datum];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setDatum:[subBuilder buildPartial]];
        break;
      }
      case 26: {
        Term_Builder* subBuilder = [Term builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addArgs:[subBuilder buildPartial]];
        break;
      }
      case 34: {
        Term_AssocPair_Builder* subBuilder = [Term_AssocPair builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addOptargs:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasType {
  return result.hasType;
}
- (Term_TermType) type {
  return result.type;
}
- (Term_Builder*) setType:(Term_TermType) value {
  result.hasType = YES;
  result.type = value;
  return self;
}
- (Term_Builder*) clearType {
  result.hasType = NO;
  result.type = Term_TermTypeDatum;
  return self;
}
- (BOOL) hasDatum {
  return result.hasDatum;
}
- (Datum*) datum {
  return result.datum;
}
- (Term_Builder*) setDatum:(Datum*) value {
  result.hasDatum = YES;
  result.datum = value;
  return self;
}
- (Term_Builder*) setDatumBuilder:(Datum_Builder*) builderForValue {
  return [self setDatum:[builderForValue build]];
}
- (Term_Builder*) mergeDatum:(Datum*) value {
  if (result.hasDatum &&
      result.datum != [Datum defaultInstance]) {
    result.datum =
      [[[Datum builderWithPrototype:result.datum] mergeFrom:value] buildPartial];
  } else {
    result.datum = value;
  }
  result.hasDatum = YES;
  return self;
}
- (Term_Builder*) clearDatum {
  result.hasDatum = NO;
  result.datum = [Datum defaultInstance];
  return self;
}
- (NSMutableArray *)args {
  return result.argsArray;
}
- (Term*)argsAtIndex:(NSUInteger)index {
  return [result argsAtIndex:index];
}
- (Term_Builder *)addArgs:(Term*)value {
  if (result.argsArray == nil) {
    result.argsArray = [[NSMutableArray alloc]init];
  }
  [result.argsArray addObject:value];
  return self;
}
- (Term_Builder *)setArgsArray:(NSArray *)array {
  result.argsArray = [[NSMutableArray alloc]init];
  return self;
}
- (Term_Builder *)clearArgs {
  result.argsArray = nil;
  return self;
}
- (NSMutableArray *)optargs {
  return result.optargsArray;
}
- (Term_AssocPair*)optargsAtIndex:(NSUInteger)index {
  return [result optargsAtIndex:index];
}
- (Term_Builder *)addOptargs:(Term_AssocPair*)value {
  if (result.optargsArray == nil) {
    result.optargsArray = [[NSMutableArray alloc]init];
  }
  [result.optargsArray addObject:value];
  return self;
}
- (Term_Builder *)setOptargsArray:(NSArray *)array {
  result.optargsArray = [[NSMutableArray alloc]init];
  return self;
}
- (Term_Builder *)clearOptargs {
  result.optargsArray = nil;
  return self;
}
@end

